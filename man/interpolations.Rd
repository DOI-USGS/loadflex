% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/interpolations.R
\name{interpolations}
\alias{distanceWeightedInterpolation}
\alias{interpolations}
\alias{linearInterpolation}
\alias{rectangularInterpolation}
\alias{smoothSplineInterpolation}
\alias{splineInterpolation}
\alias{triangularInterpolation}
\title{Interpolation functions}
\usage{
linearInterpolation(dates.in, y.in, dates.out)

triangularInterpolation(dates.in, y.in, dates.out)

rectangularInterpolation(dates.in, y.in, dates.out)

splineInterpolation(dates.in, y.in, dates.out)

smoothSplineInterpolation(dates.in, y.in, dates.out)

distanceWeightedInterpolation(dates.in, y.in, dates.out)
}
\arguments{
\item{dates.in}{A numeric vector desribing the dates for each of the values 
in \code{y.in}. Dates are represented as the number of seconds since 1970.}

\item{y.in}{A vector of values (typically fluxes or concentrations) to 
interpolate among.}

\item{dates.out}{A numeric vector of dates for which the corresponding output
values are to be produced. Dates are represented as the number of seconds 
since 1970.}
}
\value{
A vector of values (typically fluxes or concentrations), in the same 
  units and on the same scale as the \code{y.in} values, that are the 
  function's predictions for \code{y.out} at each of the dates in dates.out.
}
\description{
A set of functions that interpolate a y variable over time. See the 
Interpolation Types section for details specific to each function. These 
functions are intended for use within \code{\link{loadInterp}} and 
\code{\link{loadComp}} models.
}
\details{
These functions may assume the following without checking:

\itemize{

\item dates.in is sorted chronologically

\item y.in is sorted by dates.in

\item dates.in and dates.out are in the same numeric format

}


\code{linearInterpolation} - straight lines from one point in y.in to the 
next.

\code{triangularInterpolation} - connects each successive pair of points 
\code{i} and \code{j} by a straight line from \code{(dates.in[i], y.in[i])} 
to \code{(mean(dates.in[i], dates.in[j]), 0)} to \code{(dates.in[j], 
y.in[j])}. This function was described by Verma et al. 2012 as an option for
residuals interpolation with the composite method.

\code{rectangularInterpolation} - horizontal lines through each point 
connected by vertical lines at the midpoint between each pair of dates. This
function was described and recommended by Verma et al. 2012 as an option for
residuals interpolation with the composite method.

\code{splineInterpolation} - a smooth curve that runs through each point in 
y.in.

\code{smoothSplineInterpolation} - a smoothing spline that follows the trends
in y.in without passing through each point. This function always uses a fixed
set of arguments for smooth.spline (mostly the defaults), while 
\code{\link{getSmoothSplineInterpolation}} can produce a smooth spline 
function with the parameters of your choice.

\code{distanceWeightedInterpolation} - An inverse-distance-weighted average 
of y.in at each dates.out point. This function creates a weight for each y.in
based on the distance from dates.in to the values in dates.out. The y.out 
prediction for each value of dates.out is then the weighted average of the 
y.in values. This function always uses a fixed inverse-distance function (1/(a-b)^2),
while \code{\link{getDistanceWeightedInterpolation}} can apply the
inverse-distance function of your choice.
}
\references{
Verma, S., M. Markus, and R. A. Cooke. 2012. Development of error
  correction techniques for nitrate-N load estimation methods. Journal of 
  Hydrology 432-433:12-25.
}
\seealso{
\code{\link{getSmoothSplineInterpolation}} and 
  \code{\link{getDistanceWeightedInterpolation}} produce interpolation 
  functions of the form described here, but with flexibility in the values of
  arguments passed to the internal workhorse functions.
}

