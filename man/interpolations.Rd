% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/interpolations.R
\name{interpolations}
\alias{distanceWeightedInterpolation}
\alias{interpolations}
\alias{linearInterpolation}
\alias{rectangularInterpolation}
\alias{smoothSplineInterpolation}
\alias{splineInterpolation}
\alias{triangularInterpolation}
\title{Interpolation functions}
\usage{
linearInterpolation(dates.in, y.in, dates.out)

triangularInterpolation(dates.in, y.in, dates.out)

rectangularInterpolation(dates.in, y.in, dates.out)

splineInterpolation(dates.in, y.in, dates.out)

smoothSplineInterpolation(dates.in, y.in, dates.out)

distanceWeightedInterpolation(dates.in, y.in, dates.out)
}
\arguments{
\item{dates.in}{A numeric vector desribing the dates for each of the values
in \code{y.in}. Dates are represented as the number of seconds since 1970.}

\item{y.in}{A vector of values (typically fluxes or concentrations) to
interpolate among.}

\item{dates.out}{A numeric vector of dates for which the corresponding output
values are to be produced. Dates are represented as the number of seconds
since 1970.}
}
\value{
A vector of values (typically fluxes or concentrations), in the same
  units and on the same scale as the \code{y.in} values, that are the
  function's predictions for \code{y.out} at each of the dates in dates.out.
}
\description{
A set of functions that interpolate a y variable over time. See the
Interpolation Types section for details specific to each function. These
functions are intended for use within \code{\link{loadInterp}} and
\code{\link{loadComp}} models.
}
\details{
These functions may assume the following without checking:

\itemize{

\item dates.in is sorted chronologically

\item y.in is sorted by dates.in

\item dates.in and dates.out are in the same numeric format

}

\subsection{Interpolation Methods}{}

\code{linearInterpolation} - straight lines from one point in y.in to the
next.

\code{triangularInterpolation} - connects each successive pair of points
\code{i} and \code{j} by a straight line from \code{(dates.in[i], y.in[i])}
to \code{(mean(dates.in[i], dates.in[j]), 0)} to \code{(dates.in[j],
y.in[j])}. This function was described by Verma et al. 2012 as an option for
residuals interpolation with the composite method.

\code{rectangularInterpolation} - horizontal lines through each point
connected by vertical lines at the midpoint between each pair of dates. This
function was described and recommended by Verma et al. 2012 as an option for
residuals interpolation with the composite method.

\code{splineInterpolation} - a smooth curve that runs through each point in
y.in.

\code{smoothSplineInterpolation} - a smoothing spline that follows the trends
in y.in without passing through each point. This function always uses a fixed
set of arguments for smooth.spline (mostly the defaults), while
\code{\link{getSmoothSplineInterpolation}} can produce a smooth spline
function with the parameters of your choice.

\code{distanceWeightedInterpolation} - An inverse-distance-weighted average
of y.in at each dates.out point. This function creates a weight for each y.in
based on the distance from dates.in to the values in dates.out. The y.out
prediction for each value of dates.out is then the weighted average of the
y.in values. This function always uses a fixed inverse-distance function (1/(a-b)^2),
while \code{\link{getDistanceWeightedInterpolation}} can apply the
inverse-distance function of your choice.
}
\references{
Verma, S., M. Markus, and R. A. Cooke. 2012. Development of error
  correction techniques for nitrate-N load estimation methods. Journal of
  Hydrology 432-433:12-25.
}
\seealso{
\code{\link{getSmoothSplineInterpolation}} and
  \code{\link{getDistanceWeightedInterpolation}} produce interpolation
  functions of the form described here, but with flexibility in the values of
  arguments passed to the internal workhorse functions.
}

